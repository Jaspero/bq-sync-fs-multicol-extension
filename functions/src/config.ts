import { get, has } from 'json-pointer';
import { 
  RuntimeCollectionConfig, 
  SyncConfiguration, 
  CollectionSyncConfig,
  ParsedFieldDefinition 
} from './types/sync-config.interface';

/**
 * Global configuration
 */
export const CONFIG = {
  instanceId: process.env.EXT_INSTANCE_ID!,
  databaseId: "(default)",
  schedule: process.env.SCHEDULE || '0 0 * * *',
  timeZone: process.env.TIME_ZONE || 'UTC',
  datasetLocation: process.env.DATASET_LOCATION || 'eu',
  transformUrl: process.env.TRANSFORM_URL
};

/**
 * Load sync configuration from environment or generated config
 */
function loadSyncConfig(): SyncConfiguration | null {
  // Try loading from SYNC_CONFIG env variable first
  const syncConfigEnv = process.env.SYNC_CONFIG;
  if (syncConfigEnv) {
    try {
      return JSON.parse(syncConfigEnv) as SyncConfiguration;
    } catch (e) {
      console.warn('Failed to parse SYNC_CONFIG environment variable:', e);
    }
  }

  // Try loading from generated config file
  try {
    // This will be generated by the generate-config script
    const { SYNC_CONFIG } = require('./generated/sync-config');
    return SYNC_CONFIG as SyncConfiguration;
  } catch (e) {
    // Generated config not available
  }

  return null;
}

/**
 * Parse field definition into runtime format with accessor function
 */
function parseFieldDefinition(field: any): ParsedFieldDefinition {
  const key = field.name;
  const type = field.type;
  const accessorPath = field.accessor;
  const formater = field.formater;
  const methodStr = field.method;

  return {
    key,
    type: type.split('_')[0],
    formater,
    ...(methodStr && { method: eval(methodStr) }),
    accessor: accessorPath 
      ? (value: any) => {
          if (has(value, accessorPath)) {
            return get(value, accessorPath);
          }
          return '';
        }
      : (value: any) => value[key] || ''
  };
}

/**
 * Convert collection config to runtime format
 */
function toRuntimeConfig(config: CollectionSyncConfig): RuntimeCollectionConfig {
  // Build regex patterns for each collection path
  const pathPatterns = config.collectionPaths.map(path => {
    // Convert Firestore path pattern to regex
    // e.g., "users/{parentId}/posts" -> "^users/[^/]+/posts$"
    const regexStr = '^' + path
      .replace(/\{[^}]+\}/g, '[^/]+')
      .replace(/\//g, '\\/') + '$';
    return new RegExp(regexStr);
  });

  // Combine patterns into single regex
  const combinedPattern = new RegExp(
    pathPatterns.map(p => p.source.slice(1, -1)).join('|')
  );

  return {
    id: config.id,
    collectionPaths: config.collectionPaths,
    collectionGroup: config.collectionGroup,
    datasetId: config.datasetId,
    tableId: config.tableId,
    trackerTableId: `${config.tableId}-tracker`,
    datasetLocation: config.datasetLocation,
    backfill: config.backfill,
    includeParentIdInDocumentId: config.includeParentIdInDocumentId || false,
    transformUrl: config.transformUrl,
    schedule: config.schedule,
    timeZone: config.timeZone,
    fields: config.fields.map(parseFieldDefinition),
    pathPattern: combinedPattern
  };
}

/**
 * Get all collection configurations as runtime configs
 */
export function getCollectionConfigs(): RuntimeCollectionConfig[] {
  const syncConfig = loadSyncConfig();
  
  if (syncConfig && syncConfig.collections.length > 0) {
    return syncConfig.collections.map(toRuntimeConfig);
  }

  return [];
}

/**
 * Find the matching collection config for a document path
 */
export function findMatchingConfig(
  documentPath: string, 
  configs: RuntimeCollectionConfig[]
): RuntimeCollectionConfig | undefined {
  // Remove document ID from path for matching
  const pathParts = documentPath.split('/');
  const collectionPath = pathParts.slice(0, -1).join('/');

  for (const config of configs) {
    if (config.pathPattern.test(collectionPath)) {
      return config;
    }
  }

  return undefined;
}
